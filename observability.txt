Observability is:
- About being able to ask questions of software - what it's doing - and get answers
- Diff from metrics/logging/monitoring - being able to say "it's doing this, for this purpose, for this person"
- Because today it's not just one app server - hundreds of containers, microservices
- For people called dev, devops, product, support - are you in some way responsible for this product. Product manager may be closely watching performance. "I'm watching this metric, filter out this endpoint, on this platform..." Can pinpoint exactly what looking for, don't have to predict ahead of time.
- Not have to request access - anybody responsible for S/W can create and ask the questions
- Answering questions about your system using data
- Uses production data to inform what you develop: does use of a feature flag inform whether to do more dev? Is this thing we thought was an "edge case" really an edge case? Product managers hypothesize about these things, this lets us see what is really happening: is what they thought really being used the way they thought it would?
- Really empowering everybody - democratize the power. Often an engineering team with one repository of expertise. Want people to look it up themselves.

o11ycon - Observability con - Q: is our instrumentation good enough to make these decisions?
- About breaking down artificial silos - can we have internal PowerSchool groups like o11ycon, bringing together people from all up and down the tree?

Honeycomb.io "Observability guide"

Observability-Driven Development - you have a hypothesis about what you're doing, are we really doing it?
